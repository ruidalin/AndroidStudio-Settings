<application>
  <component name="AppStorage">
    <histories>
      <item value="2" />
      <item value="记录登录次数" />
      <item value="times" />
      <item value="领取失败" />
      <item value="receive fail" />
      <item value="Optional parameter, use null to identify a &quot;full&quot; update" />
      <item value="* Note that if you've called {@link RecyclerView.Adapter#notifyDataSetChanged()}, until the * next layout pass, the return value of this method will be {@link #NO_POSITION}." />
      <item value="* RecyclerView does not handle any adapter updates until the next layout traversal. This * may create temporary inconsistencies between what user sees on the screen and what * adapter contents have. This inconsistency is not important since it will be less than * 16ms but it might be a problem if you want to use ViewHolder position to access the * adapter. Sometimes, you may need to get the exact adapter position to do * some actions in response to user events. In that case, you should use this method which * will calculate the Adapter position of the ViewHolder." />
      <item value="* Note that this might be different than the {@link #getLayoutPosition()} if there are * pending adapter updates but a new layout pass has not happened yet." />
      <item value="* Returns the Adapter position of the item represented by this ViewHolder. * &lt;p&gt; * Note that this might be different than the {@link #getLayoutPosition()} if there are * pending adapter updates but a new layout pass has not happened yet. * &lt;p&gt; * RecyclerView does not handle any adapter updates until the next layout traversal. This * may create temporary inconsistencies between what user sees on the screen and what * adapter contents have. This inconsistency is not important since it will be less than * 16ms but it might be a problem if you want to use ViewHolder position to access the * adapter. Sometimes, you may need to get the exact adapter position to do * some actions in response to user events. In that case, you should use this method which * will calculate the Adapter position of the ViewHolder. * &lt;p&gt; * Note that if you've called {@link RecyclerView.Adapter#notifyDataSetChanged()}, until the * next layout pass, the return value of this method will be {@link #NO_POSITION}. * * @return The adapter position of the item if it still exists in the adapter. * {@link RecyclerView#NO_POSITION} if item has been removed from the adapter, * {@link RecyclerView.Adapter#notifyDataSetChanged()} has been called after the last * layout pass or the ViewHolder has already been recycled. */" />
      <item value="* Returns the Adapter position of the item represented by this ViewHolder." />
      <item value="item" />
      <item value="external" />
      <item value="* For performance and animation reasons, RecyclerView batches all adapter updates until the * next layout pass. This may cause mismatches between the Adapter position of the item and * the position it had in the latest layout calculations." />
      <item value="Holder" />
      <item value="ELLIPSIS NORMAL" />
      <item value="ELLIPSIS TWO DOTS" />
      <item value="scroll By Internal" />
      <item value="SCROLL STATE IDLE" />
      <item value="DRAGGING" />
      <item value="SETTLING" />
      <item value="SCROLL STATE SETTLING" />
      <item value="show Payment QR Code" />
      <item value="discount" />
      <item value="overflow" />
      <item value="purposes" />
      <item value="ellipsized Width" />
      <item value="ellip" />
      <item value="尾巴" />
      <item value="chaining" />
      <item value="amount to add to the default line spacing" />
      <item value="factor by which to scale the font size to get the * default line spacing" />
      <item value="spacingadd" />
      <item value="avail" />
      <item value="set Item Prefetch Enabled" />
      <item value="Commendations Adapter" />
      <item value="Commendation Adapter" />
      <item value="Game Promotions Buy Record" />
      <item value="image Receive Expand View" />
      <item value="Specifies that this view should permit nested scrolling within a compatible ancestor view" />
      <item value="领取礼包" />
      <item value="Promoiton" />
      <item value="text Promotion Gift View" />
      <item value="{ onTabClick(v); if (null == mPromotions1Fragment) { mPromotions1Fragment = new GamePromotions1Fragment(); } ActivityUtil.switchFragment(getChildFragmentManager(), R.id.layoutContentView, mPromotions1Fragment, null); break; }" />
      <item value="优惠促销" />
      <item value="活动礼包" />
      <item value="entity Type" />
      <item value="App Silent Install" />
      <item value="assistant service is not bound!!!" />
      <item value="WRITE SYNC SETTINGS" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="999" />
        <entry key="ENGLISH" value="998" />
        <entry key="ARABIC" value="1" />
        <entry key="FRENCH" value="5" />
        <entry key="DUTCH" value="1" />
        <entry key="CATALAN" value="1" />
        <entry key="CZECH" value="1" />
        <entry key="KANNADA" value="1" />
        <entry key="CROATIAN" value="1" />
        <entry key="LATIN" value="2" />
        <entry key="ROMANIAN" value="3" />
        <entry key="BENGALI" value="2" />
        <entry key="NORWEGIAN" value="1" />
        <entry key="TURKISH" value="1" />
        <entry key="SPANISH" value="1" />
        <entry key="INDONESIAN" value="3" />
        <entry key="VIETNAMESE" value="3" />
      </map>
    </option>
  </component>
  <component name="Settings">
    <option name="foldOriginal" value="true" />
    <option name="ignoreRegExp" value="" />
    <option name="overrideFont" value="true" />
    <option name="phoneticFontFamily" value="Consolas" />
    <option name="youdaoTranslateSettings">
      <youdao-translate>
        <option name="appId" value="6e2757bde9036761" />
        <option name="primaryLanguage" value="CHINESE" />
      </youdao-translate>
    </option>
  </component>
</application>