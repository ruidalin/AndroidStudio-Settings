<application>
  <component name="AppStorage">
    <histories>
      <item value="product no enough" />
      <item value="不足" />
      <item value="当前商品库存不足" />
      <item value="Promo Buy Record Entity" />
      <item value="indeterminate Drawable" />
      <item value="dismiss Timeout" />
      <item value="common" />
      <item value="m Image Intro Expand" />
      <item value="Bulletin Adapter" />
      <item value="Game Promo Buy Record View Holder" />
      <item value="Game Promo Tab 2 Fragment" />
      <item value="Game Promo Tab 1 Fragment" />
      <item value="Game Prop Tab 1 Fragment" />
      <item value="fragment game promo_" />
      <item value="promo" />
      <item value="prom" />
      <item value="fragment game promotions_1" />
      <item value="fetch Game Promotion Info" />
      <item value="fragment game bulletin" />
      <item value="fragment game proclamation" />
      <item value="Game Bulletin Detail Activity" />
      <item value="fragment game promotions" />
      <item value="fragment game introduction" />
      <item value="item promotion gift receive_1" />
      <item value="Promotion" />
      <item value="game Bulletin Id" />
      <item value="m Game Notice Id" />
      <item value="File Uri Exposed Exception" />
      <item value="More complex formatters are provided by" />
      <item value="qrcode Desc" />
      <item value="get Multi Press Timeout" />
      <item value="the duration in milliseconds we will wait to see if a touch event * is a tap or a scroll. If the user does not move within this interval, it is * considered to be a tap." />
      <item value="quick" />
      <item value="公告" />
      <item value="游戏公告" />
      <item value="2" />
      <item value="记录登录次数" />
      <item value="times" />
      <item value="领取失败" />
      <item value="receive fail" />
      <item value="Optional parameter, use null to identify a &quot;full&quot; update" />
      <item value="* Note that if you've called {@link RecyclerView.Adapter#notifyDataSetChanged()}, until the * next layout pass, the return value of this method will be {@link #NO_POSITION}." />
      <item value="* RecyclerView does not handle any adapter updates until the next layout traversal. This * may create temporary inconsistencies between what user sees on the screen and what * adapter contents have. This inconsistency is not important since it will be less than * 16ms but it might be a problem if you want to use ViewHolder position to access the * adapter. Sometimes, you may need to get the exact adapter position to do * some actions in response to user events. In that case, you should use this method which * will calculate the Adapter position of the ViewHolder." />
      <item value="* Note that this might be different than the {@link #getLayoutPosition()} if there are * pending adapter updates but a new layout pass has not happened yet." />
      <item value="* Returns the Adapter position of the item represented by this ViewHolder. * &lt;p&gt; * Note that this might be different than the {@link #getLayoutPosition()} if there are * pending adapter updates but a new layout pass has not happened yet. * &lt;p&gt; * RecyclerView does not handle any adapter updates until the next layout traversal. This * may create temporary inconsistencies between what user sees on the screen and what * adapter contents have. This inconsistency is not important since it will be less than * 16ms but it might be a problem if you want to use ViewHolder position to access the * adapter. Sometimes, you may need to get the exact adapter position to do * some actions in response to user events. In that case, you should use this method which * will calculate the Adapter position of the ViewHolder. * &lt;p&gt; * Note that if you've called {@link RecyclerView.Adapter#notifyDataSetChanged()}, until the * next layout pass, the return value of this method will be {@link #NO_POSITION}. * * @return The adapter position of the item if it still exists in the adapter. * {@link RecyclerView#NO_POSITION} if item has been removed from the adapter, * {@link RecyclerView.Adapter#notifyDataSetChanged()} has been called after the last * layout pass or the ViewHolder has already been recycled. */" />
      <item value="* Returns the Adapter position of the item represented by this ViewHolder." />
      <item value="item" />
      <item value="external" />
      <item value="* For performance and animation reasons, RecyclerView batches all adapter updates until the * next layout pass. This may cause mismatches between the Adapter position of the item and * the position it had in the latest layout calculations." />
      <item value="Holder" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="1031" />
        <entry key="ENGLISH" value="1032" />
        <entry key="ARABIC" value="1" />
        <entry key="FRENCH" value="5" />
        <entry key="DUTCH" value="1" />
        <entry key="CATALAN" value="1" />
        <entry key="CZECH" value="1" />
        <entry key="KANNADA" value="1" />
        <entry key="CROATIAN" value="1" />
        <entry key="LATIN" value="2" />
        <entry key="ROMANIAN" value="3" />
        <entry key="BENGALI" value="2" />
        <entry key="NORWEGIAN" value="1" />
        <entry key="TURKISH" value="1" />
        <entry key="SPANISH" value="1" />
        <entry key="INDONESIAN" value="3" />
        <entry key="VIETNAMESE" value="3" />
      </map>
    </option>
  </component>
  <component name="Settings">
    <option name="foldOriginal" value="true" />
    <option name="ignoreRegExp" value="" />
    <option name="overrideFont" value="true" />
    <option name="phoneticFontFamily" value="Consolas" />
    <option name="youdaoTranslateSettings">
      <youdao-translate>
        <option name="appId" value="6e2757bde9036761" />
        <option name="primaryLanguage" value="CHINESE" />
      </youdao-translate>
    </option>
  </component>
</application>